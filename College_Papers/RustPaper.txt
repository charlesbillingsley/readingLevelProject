RESULTS:
Total Sentences: 216
Total Words: 4754
Total Syllables 7672
Reading Level Score 47.96821438866297
Reading Level: College Reading Level

Rust has Never Looked Brighter
Adam Stewart
Grand Valley State University
 
Abstract
An overview of the programming language Rust, from its beginnings to a look at its future.  A decently new language, sponsored by Mozilla, in attempt to centralize a lot of existing ideas in previous languages.  These ideas are demonstrated with the existence of slices, vectors, and structs.  On top of that, the versatile options of parameter passing which include opportunities to pass by value or by reference.  The world is generally excited for what Rust contains, which is demonstrated by a survey of developers’ most loved language.
 
Rust has Never Looked Brighter
Benjamin Franklin once said “Without continual growth and progress, such words as improvement, achievement, and success have no meaning” (Franklin, n.d.).  Programming languages have always strived to take features from their predecessors and improve upon them, however it’s never achieved as elegantly as it sounds.  Rust attempts to takes features across many languages, while giving its own spice, and this is shown in the syntax, data abstractions, control abstractions, and more.

Language Introduction
The Rust programming language was created by a man named Graydon Hoare (Avram, 2012).  Hoare is currently an employee that works for Mozilla, but despite that, Rust is not owned by Mozilla (“Frequently Asked Questions”, n.d.).  Rust started as a side-project in Hoare’s life in 2006, however in 2009, Mozilla started to involve themselves by sponsoring the language (“Frequently Asked Questions”, n.d.).  Throughout the many years of development, numerous people got involved in the creation, some from Mozilla, some not (“Frequently Asked Questions, n.d.”).  The first alpha release eventually came out in 2012, with an official, stable release on May 15, 2015 (“Frequently Asked Questions”, n.d.; The Rust Core Team, 2015).  
When Hoare was asked “Why a new language?” he responded with a common reasoning of other previous programming language creators—that there’s a lot of good ideas not widely used in languages (Avram, 2012).  Just as many old languages wanted to combine aspects of a multitude of languages, Hoare did too.  He went on to mention that the languages that do implement these ideas were implemented into unsafe memory models, implying that he’s going to make a centralized safe language for these ideas (Avram, 2012).  Hoare sought out to do what he said, and on various platforms, such as Mac OS (Lion+, 32/64 bit), Windows (7+ 32/64 bit), and Linux (32/64 bit) (“The Rust Programming Language”, n.d.). 
Rust developed into a multi-paradigm language, the paradigms being viewed as partially imperative, procedural, and even a little functional. (“Frequently Asked Questions”, n.d.).  Though it isn’t object oriented, it still supports many actions a user can do in an object oriented language, just not everything, and not always by using the same abstraction. (“Frequently Asked Questions”, n.d.)  With this environment set up, Rust began seeing use for multiple types of projects; Mozilla most notably uses it for their browser engine called Servo. (“Servo”, n.d.)  It’s also notable that the company Samsung has gone out of their way to contribute to Rust and the browser Servo (Rosenblatt, 2013).  In Rust’s FAQ, it’s also mentioned that users can use a library supported by Rust named Piston to write video games. (“Frequently Asked Questions”, n.d.)  Though Rust is still early into its life, there’s multiple application domains for Rust to be used in, and there’s documentation of the entire Rust API found on the Rust website, such as their syntax and rules. 

Syntax
The actual notation of Rust is notated through EBNF (Extended Backus-Naur Form), however operators, symbols, keywords, types, etc. can all be described in English on their website (“Grammar”, 2011; “The Rust Programming Language”, n.d.).  Many people view Rust as “C-esque”, but the actual inspirations for Rust include: C++, C#, Haskell, Scheme, Swift, and even a couple smaller languages (The Rust reference, n.d.).  Contributions from these languages include: references, smart pointers, attributes, type classes, type families, hygienic macros, optional bindings, and so on (The Rust Reference, n.d.).  The most notable syntax-related influence is from Unicode Annex #31, which is where it Rust got its identifier and pattern syntax (The Rust Reference, n.d.).  Despite this, Rust is often viewed as having stand-out syntax here and there.  Weird syntax includes: parameters being a variable name, colon, then type—rather than just type then variable (as it is in languages like C or Java), and instantiation of arrays being let evens:[i32;5] = [0,2,4,6,8]; which has pretty poor writability (“The Rust Programming Language”, n.d.).  This creates an array of 32-bit integers called “evens” with a size of 5, holding the values 0, 2, 4, 6, 8.  On the other hand, it isn’t too bad to read.  Greater detail on arrays and data types later on.

Data Abstractions
Data Types
There are six notable data types in Rust: boolean, char, string, integer, unsigned, and float (“The Rust Programming Language”, n.d.).  The interesting thing about Rust is that there’s multiple version of integers, unsigns, and floats.  There exists what is denoted as i8, i16, i32, i64, u8, u16, u32, u64, f32, and f64 (“The Rust Programming Language”, n.d.).  Each number represents how many bits each data type takes (i32 = 32-bit, u8 = 8-bit, etc), that way you can personally allocate how much memory each integer, unsigned, or float takes up (from the options available) (“The Rust Programming Language”, n.d.).  There also exists integer and unsigned types called “isize” and “usize”, which are called variable-size types, however it is always mentioned that isize and usize are architecture dependent (“The Rust Programming Language”, n.d.).    Though there is only one type of char it is notable that chars in Rust are 4 bits, and represented as a Unicode scalar value (which means emojis are chars), instantiated with double single quotation marks (“The Rust Programming Language”, n.d.). 

Data Structures
Now to take a moment away from data types to talk about the structures that exist in Rust.  There are: arrays, vectors, slices, and tuples (“The Rust Programming Language”, n.d.).  Arrays are pretty self-explanatory—you pick a size and type, and that’s it, just like any other language (“Primitive Type array”, n.d.).  They can be instantiated by distinctly defining each value of the array (like let evens = [0,2,4,6,8];) or by instantiating all of the values to be the same (“Primitive Type array”, n.d.).  For example, let a = [0;5];, which makes an array of size 5, with all values equal to 0.  There also exists dynamic-like arrays called vectors, which are similar to ArrayLists in Java (“The Rust Programming Language”, n.d.).  A vector can be instantiated by using the convenient vec! macro, or by using the new function (See Appendix A; “The Rust Programming Language”, n.d.).  Vectors offer methods to remove values at specific indexes, or to simply push/pop values, just as a stack in other languages would (“Struct std::vec::Vec”, n.d.).  Slices, again similar to arrays, are simply a slice of memory (“Primitive Type slice”, n.d.).  Slices are created off of two values: a pointer to the data slicing, and then the value that is the length of the slice (“Arrays and Slices”, n.d.).  So a slice will contain values (similar to an array or vector), and it’ll contain the starting value where the pointer points to, and go until the desired length is filled, which means that Strings can also be sliced (See Appendix A).  Lastly, tuples are simply lists of values (“Primitive Type”, n.d.).  A tuple can contain a combination of types, such as (“string”, 1, ‘c’);, which is holding 3 different data types (“Primitive Type Tuple”, n.d.).  

User Defined Types
Now to do a little combining of data types and data structures, there are multiple user-defined types within Rust.  There exists: arrays, vectors, tuples structs (similar to structs in C), enums, and hashes. (“Custom Types”, n.d.).  The actual structure of arrays, vectors, and tuples were touched on in the data structures section, however each of these can have a defined type by the user.  A defined type in Rust being, any data type, or defined struct (“The Rust Programming Language”, n.d.).  Now to explain what structs actually are, they are custom made data types (“The Rust Programming Language”, n.d.).  Though structs are customizable data types, they can be a combination of other types, making it user-defined (“The Rust Programming Language”, n.d.).  For example, a struct called birthCert can be created (to represent a birth certificate), and it can be a combination of strings and unsigned values.  Strings for name and location, then unsigned integers for day, month, and year.  The birthCert struct can then be in arrays, tuples, vectors, just like any other datatype.  There also exists such a thing called “tuple structs”, which are defined the same way a normal struct would be, but without defining the fields with variable names (“The Rust Programming Language”, n.d.).
Another user-defined type are enums (short for enumerations).  Enums can consist of a variety of data types, such as strings or floats (“The Rust Programming Language”, n.d.).  Not only individually can enums hold strings and floats, but it can within the same enum as well (“The Rust Programming Language”, n.d.).  And lastly, hashes, which are quite a bit different from enums, are the last user-defined type in Rust.  Unlike enums and structs, a hash function is only made up of one type, like a integer for instance (“Module std::hash”, n.d.).  Hashes in Rust work identically to how a hash in another language would work, where values get mapped to a numerical value depending on how the hash is defined.

Mutability
All of these data types and structures have opportunities to be altered, but an interesting standard Rust has is when defining a variable the user has to define whether it’s mutable or not, similar to how one would define a variable’s type in instantiation (“The Rust Programming Language”, n.d.).  So if a variable is instantiated as let x = 3;, it cannot be added, subtracted, or altered in any other way, in its current state (“The Rust Programming Language”, n.d.).  On the other hand, if a variable is instantiated with the ‘mut’ keyword, then the variable can be altered (“The Rust Programming Language”, n.d.).  In the documentation it is specifically mentioned that only the exterior is changed as mutable/immutable (“The Rust Programming Language”, n.d.).  Even if a variable was immutable, that doesn’t mean the user couldn’t create a mutable reference to the variable (“The Rust Programming Language”, n.d.).

Pointers
After defining variables, Rust offers a way to attain variables in memory with the use of pointers.  Though Rust is a language that does contain pointers, it may not be in the simple way other languages contain them.  Rust used to have a variety of pointers, however in the latest stable version, only two types exist: reference pointers and raw pointers (“The Rust Pointer Guide”, 2011).  Reference pointers are safe, checked at compile time pointers to data, denoted to start with an ampersand, while raw pointers are unsafe, unchecked pointers that are denoted to start with an asterisk (“The Rust Programming Language”, n.d.).  

Type Checking & Coercion
Now to address how the data types of variables are checked.  Rust is a statically typed language, meaning it type checks early (“The Rust Programming Language”, n.d.).  Though the types of variables must be known up front, it can still perform type inferencing, so it’ll help the user when available. (“The Rust Programming Language”, n.d.).  Coercion, the changing of a variable’s type, can be performed using the ‘as’ keyword in Rust (“The Rust Programming Language”, n.d.).  In the documentation it is stated that explicit coercion can happen between type U and type T if T coerces with U (“The Rust Programming Language”, n.d.).  Conversion types include: any numeric type to any other numeric type, bool & char to integer type, unsigned 8-bit to char, and C-like enums with integer type (“The Rust Programming Language”, n.d.).  Conversions between numeric types possibly will truncate, or zero/sign extend, depending on the specific conversion (“The Rust Programming Language”, n.d.).

Memory Management
All of these data types and structures being talked about must reside somewhere in memory, and Rust does so elegantly.  Rust is considered a relatively low level language, and this is also represented in its memory management.  Rust uses a stack and heap and performs C-like stack allocations (“The Rust Programming Language”, n.d.).  The stack works how a normal stack works.  When a function is called, memory is automatically allocated onto the stack for the variables and such found inside the function (“The Rust Programming Language”, n.d.).  The stack builds up, adding more to it as more functions are called, and are deallocated once the functions are over (“The Rust Programming Language”, n.d.).  In situations where the user would want data to stay around longer than a function’s life, the user can use the Box<T> command to allocate something to the heap (“The Rust Programming Language”, n.d.).  In this case, the variable being allocated still goes into the stack, however the value for this variable is a pointer to where it lies in the heap (“The Rust Programming Language”, n.d.).  When you finally want it deallocated, it will by using the Drop keyword, which is implemented through Box (“The Rust Programming Language”, n.d.).  Rust tries its best to offer the user a variety of memory allocating solutions for them to work with.

Control Abstractions
Expressions
Control abstractions are the core of the language.  Rust programs are typically made up from a series of statements (“Expressions”, n.d.).  Rust is also a primarily expression based language, meaning most statements are expressions (“The Rust Reference”, n.d.).  The Rust Reference defines expression statements as an expression that evaluates its expression and ignores its result (“The Rust Reference”, n.d.).  An expression itself is said to have the roles of always producing a value, and possibly containing side effects (“The Rust Reference”, n.d.).  There are a multitude of expression types, such as: literal, path, tuple, struct, block, method-call, field, array, index, and ranges (“The Rust Reference”, n.d.).

Operators
Rust contains a library of binary operators to use within their expressions, most of which are standard (“The Rust Reference”, n.d.).  Operators include (and in order of precedence): multiplication, division, and remainder, then addition and subtraction, then shift left and shift right, then bit-and, then bit-or, then bit-xor, then equivalence, not equals, greater than, less than, less than equal, and greater than equal, then logical and, then logical or, and then finally the assignment operator (“The Rust Reference”, n.d.).  The operators with the same precedence are always evaluated from left to right (“The Rust Reference”, n.d.).  

Selection Constructs
Now for the methods of pathing through code with constructs.  There are two primary types of selection constructs.  An obvious kind is an if-statement, which works like any normal if statement from any language (“The Rust Reference”, n.d.).  There’s no ‘end’ keyword, it’s just an if-statement with blocks denoted with curly braces, with ‘else’s available (else blocks also denoted with curly braces).  The other kind is a match-statement, which does exactly what it sounds like it does—matches an expression to a result (“The Rust Reference”, n.d.).  This is basically the equivalent to a switch-statement in other languages like Java.  There also exists an if-let-statement, which is the same as an if-statement, but with a let-statement inside the boolean expression, so for example: if let (“Adam”, me) = name { //stmt } (“The Rust Reference”, n.d.).  

Iterative Constructs
The iterative constructs that exist in Rust are while loops, for loops, and infinite loops.  While loops work the same as while loops in other languages—the loop will run while the expression is true (“The Rust Programming Language”, n.d.).  Similar to if and if-let, there’s a while-let.  It operates the same as a while loop, however where the expression-condition is expected, it also expects a let-statement (“The Rust Reference”, n.d.).  Though Rust is often referred to being C-like, the syntax for for-loops is a bit different than C (“The Rust Programming Language”, n.d.).  The normal C syntax is for(initialize; compare; increment), however in Rust it is denoted as for(variable in expression) syntax (“The Rust Programming Language”, n.d.).  The third kind of loops in Rust are infinite loops, and though these exist in every language with loops, most don’t have a dedicated syntax for it (“The Rust Reference”, n.d.).  All that simply must be done is loop { }, with all that is being looped in the block (“The Rust Reference”, n.d.).  All iterative loops can be broken out of early or have parts skipped with the ‘break’ and ‘continue’ commands (“The Rust Programming Language”, n.d.).  The ‘break’ command simply will break out of the entire loop, and it’ll be done; this is especially useful for infinite loops, so that they aren’t infinite (“The Rust Programming Language”, n.d.).  ‘Continue’ is a little different in that it won’t break out of a loop, but once the ‘continue’ command is reached, it’ll skip the rest of that specific iteration, and start back at the head of the loop (“The Rust Programming Language”, n.d.).  Loops can also have labels, which can greatly help readability (“The Rust Programming Language”, n.d.).  Basically, the user could say continue ‘outer;, showing that the loop will continue and go to the outer loop (“The Rust Programming Language”, n.d.).

Functions & Methods
Putting variables, types, and expressions together, the user can create functions.  Every program must have at least one function (using keyword ‘fn’), that being a ‘main’, but can of course contain as many as needed (“Functions”, n.d.).  Functions can have multiple parameters, with multiple types, and can also return any primitive or struct type (“Functions”, n.d.).  To distinctly show what a function is returning, the user will denote with an arrow ‘->’ then return type after the parameters (“Functions”, n.d.).  If the keyword ‘return’ isn’t distinctly used to return a value, then the last expression of the function will be used as the return statement (“Functions”, n.d.).  Also, since Rust can technically return tuples, this allows the user to return multiple values at once.    
Despite Rust not being object oriented, and already containing the existence of functions, it also has method calls (“The Rust Programming Language”, n.d.).  Blocks of methods can be denoted with the ‘impl’ keyword followed by the name of a struct that the method is being written for (“The Rust Programming Language”, n.d.).  Within this block, functions can be written for the struct—written just as regular functions are written, but now these functions actually operate as function calls to the specified struct (“The Rust Programming Language”, n.d.).

Parameter Passing & Scope
To deliver variable values to function parameters, Rust consists of a copy function.  The copy function will do exactly what it sounds like, copy a value, however only some data types are supported by it (“Frequently Asked Questions”, n.d.).  When a variable with a data type supported by the copy function is passed as a parameter, it’ll pass a copy, meaning it’s passed by value (“Frequently Asked Questions”, n.d.).  What it will do when a variable passed can’t be copied is that it’ll instead move the variable itself into the function (“The Rust Programming Language”, n.d.).  This can cause’ problems because if that same variable isn’t returned, the user won’t be able to use it anymore, it’ll give an error saying “use of moved value” (“The Rust Programming Language”, n.d.).  This is because when the value was moved into the function, it’s never moved back (again, unless the value is returned).  A way to avoid such a problematic situation is to pass by reference (“The Rust Programming Language”, n.d.)!  Passing by reference can be done in Rust simply by having the function parameter be a specific type with a reference pointer (“The Rust Programming Language”, n.d.).  The ampersand signifies a reference pointer of a variable, and only one reference can be pulled per variable, within a given scope (“The Rust Programming Language”, n.d.).  So instead of running into an “unable to use moved value” error, it’ll instead not move the actual value, and move a reference to that variable.  As for the actual variables, Rust has dynamic scoping (“The Rust Programming Language”, n.d.).  Rust also has variable shadowing, meaning that if two variables have the same name, it’ll default to the variable closest in scope dynamically (“The Rust Programming Language”, n.d.).  For instance, this means the user could have variables with the same name as parameters in functions.

Support for Modules & Exception Handling
Pre-existing support exists for the user and their functions through modules and exception handling.  Rust consists of “crates” (aka packages), which contains modules (“The Rust Programming Language”, n.d.).  The modules within a crate are designed in a tree-like structure, that way name collisions don’t occur (“The Rust Programming Language”, n.d.).  This way, if two modules did have the same name, they’d have different paths amongst the tree (“The Rust Programming Language”, n.d.).  As for error handling, Rust offers a lot of options for the user.  Errors can easily be created and given thanks to the panic! macro (“The Rust Programming Language”, n.d.).  The handling part of the errors can be dealt with in functions by having basically a correct or “Ok” return, and a wrong or “Err” return, meaning a function will return the correct result whenever possible, and error whenever necessary (“The Rust Programming Language”, n.d.).  This process can be further simplified thanks in part to the try! macro which simulates the said process, or in other words basically functioning like a try-catch statement in other languages (“The Rust Programming Language”, n.d.).  

Input/Output
As far as interacting with the user, Rust can easily read text files with a variety of functions available to get it done, thanks to the std::io module (“Module std::io”, n.d.).  Rust can seek and read files through a desired amount of bytes, making it easy to get the result for a single line for instance (“Module std::io”, n.d.).  On top of that, user inputs can easily be received with io::stdin() and put into a string (“Module std::io”, n.d.).  If the user doesn’t feel like using the println! macro, then they can write out with io::stdout() (“Module std::io”, n.d.).

Other Supported Features
Inheritance
Another supported feature in Rust is inheritance.  Rust can use inheritance in its structs and methods (“The Rust Programming Language”, n.d.).  Generic functions can be created of type T that’ll run only if a certain method exists, that way only specific types can actually run it (“The Rust Programming Language”, n.d.).  In other words, if the user had methods that ran for a structure of student IDs, they’d only want to run an inherited trait on the student ID structure (along with any other structs that’ve inherited it), not with every type that exists.

Concurrency
Concurrency is also supported throughout Rust (“The Rust Programming Language”, n.d.).  Rust has two traits that help concurrency work, and that’s the ‘send’ trait, and the ‘sync’ trait (“The Rust Programming Language”, n.d.).  When the send trait is implemented, it allows ownership to travel safely amongst multiple threads (“The Rust Programming Language”, n.d.).  When the sync trait is implemented it means that this type has no memory unsafety when shared as a reference amongst multiple threads (“The Rust Programming Language”, n.d.).  Both traits try to make Rust as flexible as possible when running concurrently.  
Reflection & Introspection
One of Rust’s supported, but not completely fleshed on features is its limited reflection with the use of the reflect trait (“Trait std::marker::Reflect”, n.d.).  All types implement the trait reflect so that they’re type checked, however in its current state, as of November 2016, the trait is labeled unstable (“Trait std::marker::Reflect”, n.d.).  Ultimately, reflection and introspection don’t exist in what they would in a different language (Chevalier, 2012). 

Language Critique
Overall, Rust has a lot of good things going for it.  The language is well defined with options for all of Rust’s notation through EBNF and the English language (“Grammar”, 2011; “The Rust Programming Language”, n.d.).  As far as provability is concerned, the compiler is great.  It’ll tell the user what went wrong and why, in great detail.  Rust offers the user every opportunity to write reliable code with all of its macros and functions built in.  In the latest stable update of Rust, the core dev team even wrote that one of their primary focuses was on reliability (The Rust Core Team, 2016).  The actual translation is one of the slower ones encountered in a language; a simple “Hello World” compile took a good second to compile (which may not be representative of the compiler as a whole).  In the rust FAQ, the reasoning for “slow” compile is due to the high level abstractions that have to be compiled down to machine code (“Frequently Asked Questions”, n.d.).  The actual efficiency of Rust is great; it’s even mentioned in the same FAQ that Rust is comparable to languages like C and C++ on its low-level-ness (“Frequently Asked Questions”, n.d.).  Rust’s orthogonality is up in the air.  Though Rust offers many ways to instantiate an integer (i8, i16, i32, i64, isize), which would imply poor orthogonality, it offers simplicity in that integers can be instantiated by doing let x = 1;, and that all types of an integer will work with functions that take integers.  Rust offers generality with an example being able to pass variables as references (“The Rust Programming Language”, n.d.).  This means a data type like a string has the options to be passed by value, naturally, or passed by reference explicitly (“Frequently Asked Questions”, n.d.).  Rust contains accepted notation in their documentation pages, labeled in EBNF, and consistently operates as expected (“Grammar”, 2011).  As mentioned before, despite instantiating different integer sizes, it’ll run as expected, only truncating when one would have expected.  The actual tools a user has to code with are great, with the user being able to code without the standard library, if requested (“Frequently Asked Questions”, n.d.).  On the other hand, if more features are wanted, modules and crates can be easily created by the user, or downloaded from others (“The Rust Programming Language”, n.d.).  This sometimes hurts portability, but the files can always be transferred, and Rust compilers run on Mac, Linux, and Windows (“The Rust Programming Language”, n.d.).  From beginning to end, there’s a lot of features for the user-base to be happy about.

Future and Conclusion
The world is generally excited for the future of Rust.  In a StackOverflow survey, developers’ most loved language is Rust, and is in the top 5 for the second year in a row (“Developer Survey Results”, 2016).  The latest stable release happened just a month ago from writing this, so the programming language development team is making moves to help their developers (The Rust Core Team, 2016).  With many concrete features already established in Rust’s language, there’s only room for improvement, achievement, and success.
 
References
Arrays and Slices. (n.d.). Retrieved from http://rustbyexample.com/primitives/array.html
Avram, A. (2012, Aug. 3). Interview on Rust, a Systems Programming Language Developed by Mozilla. Retrieved from https://www.infoq.com/news/2012/08/Interview-Rust 
Chevalier, T. (2012, Jul. 10). [rust-dev] Reflection system. Retrieved from https://mail.mozilla.org/pipermail/rust-dev/2012-July/002064.html 
Developer Survey Results 2016. (2016). Retrieved from http://stackoverflow.com/research/developer-survey-2016 
Expressions. (n.d.). Retrieved from http://rustbyexample.com/expression.html 
Franklin, B. (n.d.). BrainyQuote.com. Retrieved from https://www.brainyquote.com/quotes/quotes/b/benjaminfr387287.html 
Frequently Asked Questions. (n.d.). Retrieved from https://www.rust-lang.org/en-US/faq.html 
Functions. (n.d.). Retrieved from http://rustbyexample.com/fn.html 
Grammar. (2011). Retrieved from https://doc.rust-lang.org/grammar.html 
Module std::hash. (n.d.). Retrieved from https://doc.rust-lang.org/std/hash/
Module std::io. (n.d.). Retrieved from https://doc.rust-lang.org/std/io/
Primitive Type array. (n.d.). Retrieved from https://doc.rust-lang.org/std/primitive.array.html 
Primitive Type slice. (n.d.). Retrieved from https://doc.rust-lang.org/std/primitive.slice.html 
Primitive Type tuple. (n.d.). Retrieved from https://doc.rust-lang.org/std/primitive.tuple.html 
Rosenblatt, S. (2013, Apr. 3). Samsung joins Mozilla’s quest for Rust. Retrieved from https://www.cnet.com/news/samsung-joins-mozillas-quest-for-rust/ 
The Rust Pointer Guide. (2011). Retrieved from https://doc.rust-lang.org/guide-pointers.html
The Rust Programming Language. (n.d.). Retrieved from https://doc.rust-lang.org/stable/book/README.html 
The Rust Reference. (n.d.). Retrieved from https://doc.rust-lang.org/reference.html  
Servo. (n.d.). Retrieved from http://servo.org/ 
Struct std::vec::Vec. (n.d.). Retrieved from https://doc.rust-lang.org/std/vec/struct.Vec.html
Trait std::marker::Reflect. (n.d.). Retrieved from https://doc.rust-lang.org/std/marker/trait.Reflect.html
The Rust Core Team (2015, May 15). Announcing Rut 1.0 [Web log post]. Retrieved from https://blog.rust-lang.org/2015/05/15/Rust-1.0.html 
The Rust Core Team (2016, Oct. 20). Announcing Rust 1.12.1 [Web log post]. Retrieved from https://blog.rust-lang.org/2016/10/20/Rust-1.12.1.html 
